#include <iostream>
#include <random>
#include <cmath>
#include <chrono>
#include <mpi.h>

/**
 * The idea is to estimate the value of pi using a Monte Carlo simulation,
 * following the idea presented in the University of Washington CS handout:
 * https://courses.cs.washington.edu/courses/cse160/16wi/sections/07/Section07Handout.pdf
 *
 * Consider a circle of radius r centered at the origin and the square that fully contains it,
 * with side length 2r. Their areas are:
 *
 *      Area_circle  =  pi*r^2
 *      Area_square  =  (2r)^2 = 4 r^2
 *
 * The ratio between them is:
 *
 *      Area_circle / Area_square = pi/4
 *
 * If we can estimate this ratio experimentally, we can solve for pi:
 *
 *      pi ~= 4 * (points_inside_circle / total_points)
 *
 * Monte Carlo Simulation:
 * A Monte Carlo method uses randomness to estimate quantities that are difficult
 * or expensive to compute analytically. Here, we generate uniform pseudorandom
 * points in the square [-r, r] x [-r, r] and count how many fall inside the circle
 * x² + y² <= r².
 *
 * The idea is similar to dropping grains of sand randomly on the square:
 * the fraction that land inside the circle approximates the ratio of the areas.
 * Multiply that ratio by 4 to obtain an estimate of pi.
 *
 * Increasing the number of random samples (n_total) improves the accuracy,
 * but in an increasingly bad ratio.
 *
 * Additional references:
 * https://medium.com/the-modern-scientist/estimating-pi-using-monte-carlo-methods-dbdf26c888d6
 * https://www.geeksforgeeks.org/dsa/estimating-value-pi-using-monte-carlo/
 * https://www.101computing.net/estimating-pi-using-the-monte-carlo-method/
 * https://www.reddit.com/r/learnpython/comments/rgahhy/calculating_pi_accurately_with_monte_carlo_method/
*/

double random_around_zero(double r, std::mt19937 &gen) {
    // converts the raw random bits from the generator
    // into real numbers uniformly distributed in the interval [-r, r]
    std::uniform_real_distribution<double> dist(-r, r);
    return dist(gen);
}

void random_throw(double r, std::mt19937 &gen, double &x, double &y) {
    x = random_around_zero(r, gen);
    y = random_around_zero(r, gen);
}

bool in_circle(double r, double x, double y) {
    return std::sqrt(x*x + y*y) <= r;
}

unsigned long number_in_circle(unsigned long n_total, int rank, double r = 0.5) {
    // uses the OS own entropy to try to produce a non-deterministic seed
    std::random_device rd;
    // we use the mt19937 algorithm for generating the random numbers,
    // mt stands for Mersenne Twister, while the 19937 represents the sequence of numbers generated by the algorithm before
    // it starts repeating itself (2^19937). This algorithm was created with Monte Carlo in mind, as said by the authors
    // https://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/emt.html
    std::mt19937 gen(rd() ^ (rank + 1));
    unsigned long n_circle = 0;

    for (unsigned long i = 0; i < n_total; i++) {
        double x, y;
        random_throw(r, gen, x, y);
        if (in_circle(r, x, y))
            n_circle++;
    }
    return n_circle;
}

int main(int argc, char** argv) {
    MPI_Init(nullptr, nullptr);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    unsigned long n_total = 60000000000; // 60 bi -> ~624s

    if (argc > 1) {
        n_total = static_cast<unsigned long>(std::strtoul(argv[1], nullptr, 10));
    }

    unsigned long n_local = n_total / size; // we divide the number of samples for each rank

    auto t0 = std::chrono::high_resolution_clock::now();

    unsigned long n_circle_local = number_in_circle(n_local, rank);
    unsigned long n_circle_global = 0;
    MPI_Reduce(&n_circle_local, &n_circle_global, 1, 
               MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);

    auto t1 = std::chrono::high_resolution_clock::now();

    if(rank == 0) {
        double pi = 4.0 * double(n_circle_global) / double(n_total);
        double seconds = std::chrono::duration<double>(t1 - t0).count();

        std::cout << "n=" << n_total << " pi=" << pi << " time=" << seconds << "s\n";
    }

    MPI_Finalize();

    return 0;
}
